# USEFUL: https://github.com/jOOQ/sakila

# DQL в PostgreSQL

## Подготовка к занятию

```postgresql
DROP DATABASE IF EXISTS otus_dql;
CREATE DATABASE otus_dql;
```

```
\c otus_dql
```

```postgresql
\pset null [NULL]
```

## Введение

```postgresql
CREATE TABLE buses (
    bus_id serial,
    name   varchar
);
```

```postgresql
CREATE TABLE drivers (
    driver_id   serial,
    first_name  varchar,
    second_name varchar
);
```

```postgresql
CREATE TABLE routes (
    route_id  serial,
    name      varchar,
    bus_id    int,
    driver_id int
);
```

```postgresql
INSERT INTO buses
       (bus_id, name)
VALUES (1, 'ПАЗ'),
       (2, 'ЛИАЗ'),
       (3, 'MAN'),
       (4, 'МАЗ'),
       (5, 'НЕФАЗ');
```

```postgresql
INSERT INTO drivers
       (driver_id, first_name, second_name)
VALUES (1, 'Иван', 'Иванов'),
       (2, 'Петр', 'Петров'),
       (3, 'Савелий', 'Сидоров'),
       (4, 'Антон', 'Шторкин'),
       (5, 'Олег', 'Зажигаев'),
       (6, 'Аркадий', 'Паровозов');
```

```postgresql
INSERT INTO routes
       (route_id, name, bus_id, driver_id)
VALUES (1, 'Москва-Болшево', 1, 1),
       (2, 'Москва-Пушкино', 1, 2),
       (3, 'Москва-Ярославль', 2, 3),
       (4, 'Москва-Кострома', 2, 4),
       (5, 'Москва-Волгорад', 3, 5),
       (6, 'Москва-Иваново', null, null);
```

```postgresql
SELECT * FROM buses;
```

```postgresql
SELECT * FROM drivers;
```

```postgresql
SELECT * FROM routes;
```

## JOINs

### INNER JOIN

```postgresql
SELECT * FROM routes r
    JOIN buses b ON r.bus_id = b.bus_id
    JOIN drivers d on r.driver_id = d.driver_id;
```

```postgresql
SELECT * FROM routes r
    JOIN buses b USING (bus_id)
    NATURAL JOIN drivers d;
```

На небольших таблицах выгоднее сначала отсортировать данные через Merge Join:

```postgresql
EXPLAIN ANALYZE
SELECT * FROM routes r
    JOIN buses b ON r.bus_id = b.bus_id
    JOIN drivers d on r.driver_id = d.driver_id;
```

Эквивалентный запрос без JOIN:

```postgresql
EXPLAIN ANALYZE 
SELECT * FROM routes r, buses b
    WHERE r.bus_id = b.bus_id;
```

### LEFT/RIGHT JOIN

```postgresql
SELECT * FROM routes r
    LEFT JOIN buses b
    ON r.bus_id = b.bus_id;
```

```postgresql
SELECT * FROM routes r
    RIGHT JOIN buses b
    ON r.bus_id = b.bus_id;
```

Что вернёт этот запрос?

```
 route_id |       name       | bus_id | driver_id | bus_id |  name
----------+------------------+--------+-----------+--------+--------
        1 | Москва-Болшево   |      1 |         1 |      1 | ПАЗ
        2 | Москва-Пушкино   |      1 |         2 |      1 | ПАЗ
        3 | Москва-Ярославль |      2 |         3 |      2 | ЛИАЗ
        4 | Москва-Кострома  |      2 |         4 |      2 | ЛИАЗ
        5 | Москва-Волгорад  |      3 |         5 |      3 | MAN
        6 | Москва-Иваново   | [NULL] |    [NULL] | [NULL] | [NULL]
```

```postgresql
SELECT * FROM routes r
    LEFT JOIN buses b
    ON r.bus_id = b.bus_id
    WHERE b.bus_id = null;
```

.
.
.

```postgresql
SELECT * FROM routes r
    LEFT JOIN buses b
    ON r.bus_id = b.bus_id
    WHERE b.bus_id IS NULL;
```

### FULL JOIN

```postgresql
SELECT * FROM routes r
    FULL JOIN buses b
    ON r.bus_id = b.bus_id;
```

```postgresql
SELECT * FROM routes r
    FULL JOIN buses b
    ON r.bus_id = b.bus_id
    WHERE r.route_id IS NULL OR b.bus_id IS NULL;
```

### CROSS JOIN

Для Cross JOIN не нужно условие соединения:

```postgresql
SELECT * FROM routes r
    CROSS JOIN buses b;
```

```postgresql
EXPLAIN ANALYZE
SELECT * FROM routes r
    CROSS JOIN buses b;
```

Эквивалент без JOIN:

```postgresql
SELECT * FROM routes r, buses b;
```

### LATERAL JOIN

В PostgreSQL LATERAL JOIN — это тип соединения, который позволяет ссылаться на столбцы из таблицы, уже упомянутой в запросе, в последующих выражениях FROM. Это полезно, когда требуется выполнить подзапрос или функцию, который зависит от значений из предыдущей строки.

Когда использовать LATERAL JOIN?

- Если вам нужно выполнить подзапрос или функцию, результаты которого зависят от текущей строки или записи из предыдущей таблицы.
- Для создания динамических вычислений на основе значений из предыдущей таблицы.
- Для работы с функциями, возвращающими таблицы (например, jsonb_array_elements, unnest, и т. д.), когда эти функции требуют параметров из текущей строки.

```postgresql
CREATE TABLE products AS
    SELECT id AS product_id,
           id * 10 * random() AS price,
           'Product ' || id AS product
    FROM generate_series(1, 1000) AS id;
```

```postgresql
CREATE TABLE wishlist (
    wishlist_id   int,
    username      varchar,
    desired_price numeric
);
```

```postgresql
INSERT INTO wishlist
       (wishlist_id, username, desired_price)
VALUES (1, 'Hans', 450),
       (2, 'Joe', 60),
       (3, 'Jane', 1500);
```

```postgresql
SELECT * FROM products LIMIT 10;
```

```postgresql
SELECT * FROM wishlist;
```

```postgresql
SELECT * FROM wishlist w
    LEFT JOIN LATERAL (
        SELECT * FROM products p
            WHERE p.price < w.desired_price
            ORDER BY p.price DESC
            LIMIT 5
        ) -- Здесь ошибка!
    ON true
    ORDER BY wishlist_id, price DESC;
```

```postgresql
SELECT * FROM wishlist w
    LEFT JOIN LATERAL (
        SELECT * FROM products p
            WHERE p.price < w.desired_price
            ORDER BY p.price DESC
            LIMIT 5
        ) AS x -- Обязательно указываем alias!
    ON true
    ORDER BY wishlist_id, price DESC;
```

```postgresql
SELECT * FROM wishlist w, -- Здесь запятая!
    LATERAL (             -- Эквивалент CROSS JOIN LATERAL
        SELECT * FROM products p
            WHERE p.price < w.desired_price
            ORDER BY p.price DESC
            LIMIT 5
        ) AS x
    ORDER BY wishlist_id, price DESC;
```

Сравниваем планы запросов для LATERAL и CTE:

```postgresql
EXPLAIN ANALYZE
SELECT * FROM wishlist w
    LEFT JOIN LATERAL (
        SELECT * FROM products p
            WHERE p.price < w.desired_price
            ORDER BY p.price DESC
            LIMIT 5
        ) AS x
    ON true
    ORDER BY wishlist_id, price DESC;
```

```postgresql
EXPLAIN ANALYZE
WITH ranked_products AS (
    SELECT w.wishlist_id,
           w.username,
           p.product_id,
           p.price,
           p.product,
           ROW_NUMBER() OVER (
               PARTITION BY w.wishlist_id
               ORDER BY p.price DESC
           ) AS rn
    FROM wishlist w
    JOIN products p ON p.price < w.desired_price
)
SELECT w.wishlist_id,
       w.username,
       rp.product_id,
       rp.price,
       rp.product
    FROM wishlist w
    LEFT JOIN ranked_products rp
    ON w.wishlist_id = rp.wishlist_id
    AND rp.rn <= 5
    ORDER BY w.wishlist_id,
             rp.price DESC;
```

### Порядок JOIN (параметры планировщика)

```postgresql
DROP TABLE IF EXISTS test;
```

```postgresql
CREATE TABLE test AS
    SELECT (random()*100)::int AS id,
           'Product ' || id AS product
    FROM generate_series(1, 10000) AS id;
```

```postgresql
SELECT * FROM test LIMIT 10;
```

```postgresql
DROP TABLE IF EXISTS test_2;
```

```postgresql
CREATE TABLE test_2
    (id int);
```

```postgresql
INSERT INTO test_2
       (id)
VALUES (1);
```

```postgresql
SELECT * FROM  test_2 t2
    INNER JOIN test   t1 ON t2.id = t1.id
    INNER JOIN test_2 t3 ON t3.id = t2.id;
```

Реальный порядок соединения таблиц отличается от порядка в запросе:

```postgresql
EXPLAIN
SELECT * FROM  test_2 t2
    INNER JOIN test   t1 ON t2.id = t1.id
    INNER JOIN test_2 t3 ON t3.id = t2.id;
```

```postgresql
SHOW enable_hashjoin;      -- on
SHOW enable_mergejoin;     -- on
SHOW enable_nestloop;      -- on
SHOW join_collapse_limit;  -- 8
```

```postgresql
SELECT name, setting
    FROM pg_settings
    WHERE name LIKE '%join%'
       OR name = 'enable_nestloop';
```

Планировщик имеет право "переставить местами" только несколько JOIN:

```postgresql
SET join_collapse_limit TO 1;
```

```postgresql
SET join_collapse_limit TO 8;
```

## Операции над множествами

```postgresql
DROP TABLE IF EXISTS top_rated_films;
```

```postgresql
CREATE TABLE top_rated_films(
	title        varchar,
	release_year smallint
);
```

```postgresql
DROP TABLE IF EXISTS most_popular_films;
```

```postgresql
CREATE TABLE most_popular_films(
	title        varchar,
	release_year smallint
);
```

```postgresql
INSERT INTO top_rated_films
       (title, release_year)
VALUES ('The Shawshank Redemption', 1994),
       ('The Godfather', 1972),
       ('12 Angry Men', 1957);
```

```postgresql
INSERT INTO most_popular_films
       (title, release_year)
VALUES ('An American Pickle', 2020),
       ('The Godfather', 1972),
       ('Greyhound', 2020);
```

```postgresql
SELECT * FROM top_rated_films;
```

```postgresql
SELECT * FROM most_popular_films;
```

### UNION

```postgresql
SELECT * FROM top_rated_films
UNION
SELECT * FROM most_popular_films;
```

```postgresql
SELECT * FROM top_rated_films
UNION ALL
SELECT * FROM most_popular_films;
```

### EXCEPT

```postgresql
SELECT * FROM top_rated_films
EXCEPT
SELECT * FROM most_popular_films;
```

### INTERSECT

```postgresql
SELECT * FROM top_rated_films
INTERSECT
SELECT * FROM most_popular_films;
```

## CTE

### Рекурсивные CTE

```postgresql
DROP TABLE IF EXISTS orders;
```

```postgresql
CREATE TABLE orders (
    order_id serial PRIMARY KEY,
    year     smallint not null,
    amount   decimal(10,2) not null
);
```

```postgresql
INSERT INTO orders
       (year, amount)
VALUES (2020, 4500.00),
       (2020, 550.00),
       (2020, 20.00),
       (2022, 2250.00),
       (2022, 780.00),
       (2023, 11000.00),
       (2023, 5700.00),
       (2024, 0.00),
       (2024, 1200.00);
```

```postgresql
SELECT * FROM orders ORDER BY year;
```

Как посчитать сумму заказов по годам?

```
 year |  total
------+----------
 2020 |  5070.00
 2021 |     0.00
 2022 |  3030.00
 2023 | 16700.00
 2024 |  1200.00
```

.
.
.

```postgresql
SELECT year,
       sum(amount) AS total
    FROM orders
    GROUP BY year
    ORDER BY year;
```

Тривиальное CTE:

```postgresql
WITH years AS (
    SELECT 2020 AS year
    UNION
    SELECT 2021
    UNION
    SELECT 2022
    UNION
    SELECT 2023
    UNION
    SELECT 2024
)
SELECT year FROM years;
```

Рекурсивное CTE:

```postgresql
WITH RECURSIVE years AS (
    SELECT 2020 AS year
    UNION
    SELECT year + 1 FROM years WHERE (year + 1) <= 2024
)
SELECT * FROM years;
```

CTE + JOIN:

```postgresql
WITH RECURSIVE years AS (
    SELECT 2020 AS year
    UNION
    SELECT year + 1 FROM years WHERE (year + 1) <= 2024
)
SELECT years.year,
       sum(amount) AS total
    FROM years
    LEFT JOIN orders ON orders.year = years.year
    GROUP BY years.year
    ORDER BY years.year;
```

Избавляемся от NULL:

```postgresql
WITH RECURSIVE years AS (
    SELECT 2000 AS year
    UNION
    SELECT year + 1 FROM years WHERE (year + 1) <= 2024
)
SELECT years.year,
       coalesce(sum(amount), 0.00) AS total
    FROM years
    LEFT JOIN orders ON orders.year = years.year
    GROUP BY years.year
    ORDER BY years.year;
```

### Работа с иерархическими данными

```postgresql
DROP TABLE IF EXISTS fias;
```

```postgresql
CREATE TABLE fias (
    code        varchar PRIMARY KEY,
    parent_code varchar
);
```

```postgresql
INSERT INTO fias
       (code, parent_code)
VALUES ('Мамаев Курган', 'Волгоград'),
       ('Камышин', 'Волгоградская область'),
       ('Центральная набережная', 'Волгоград'),
       ('Волгоград', 'Волгоградская область'),
       ('Воронеж', 'Воронежская область'),
       ('Мега', 'Химки'),
       ('Волгоградская область', null),
       ('Волжский', 'Волгоградская область'),
       ('Химки', 'Московская область'),
       ('Московская область', null);
```

```postgresql
SELECT * FROM fias;
```

```
          code          |      parent_code
------------------------+-----------------------
 Мамаев Курган          | Волгоград
 Камышин                | Волгоградская область
 Центральная набережная | Волгоград
 Волгоград              | Волгоградская область
 Воронеж                | Воронежская область
 Мега                   | Химки
 Волгоградская область  | <NULL>
 Волжский               | Волгоградская область
 Химки                  | Московская область
 Московская область     | <NULL>
```

Как вывести записи в иерархическом порядке (и без Воронежа)?

```
          code          |      parent_code
------------------------+-----------------------
 Волгоградская область  | <NULL>
 Московская область     | <NULL>
 Камышин                | Волгоградская область
 Волгоград              | Волгоградская область
 Волжский               | Волгоградская область
 Химки                  | Московская область
 Мамаев Курган          | Волгоград
 Центральная набережная | Волгоград
 Мега                   | Химки
```

.
.
.

```postgresql
SELECT * FROM fias
  WHERE parent_code IS NULL;
```

```postgresql
WITH RECURSIVE locations AS (
    SELECT * FROM fias
        WHERE parent_code IS NULL
    UNION
    SELECT fias.* FROM fias
        JOIN locations
        ON fias.parent_code = locations.code
)
SELECT * FROM locations;
```

## Ссылка на опрос

```
https://otus.ru/polls/129462/
```